---
title: "**Projet Nycflights**"
author: "Hurgland-Nick KELIET"
date: "18/04/2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
---
**Import de Librairie**
```{r }
library(tidyr)
library(RMySQL)
library(tidyverse)
library(plotly)
library(leaflet)
```


**Connection à MYSQL**
```{r }
connection = dbConnect(MySQL(), user='hurgland-nick', password='*********', dbname='nycflights', host='localhost')
```


**Liste des tables et des champs**
```{r }
#dbListTables(connection)
#dbListFields(connection, 'flights')
```

**Récupération des Tables**
```{r }
flights <- dbReadTable(connection, 'flights')
airlines <- dbReadTable(connection, 'airlines')
airports <- dbReadTable(connection, 'airports')
weather <- dbReadTable(connection, 'weather')
planes <- dbReadTable(connection, 'planes')

```

## **Data Wrangling: Se familiariser avec les données**

**1. Identifier les potentielles clés primaires (PK), clés étrangères (FK) et les éventuelles relations entre les différentes tables (one to one, one to many, many to many) en vue de construire la BD SQL ?**
```{r }
# Done!!!! voir le schéma et les réponses et le fichier sur les process
```

# Récupérer les data de Mysql
**2. Combien y-a-t-il d’aéroports, de compagnies, de destinations, d’avions, de fuseaux horaires et de zones aux Etats-Unis où on ne passe pas à l’heure d’été (indice : colonne dst) ?**
```{r}
#On aurait pu utiliser au dbgetQuery pour directement le sortir en dataframe
#Le nombre d’aéroports
question_2 <- dbSendQuery(connection, 'select count(faa) as nombre_d_aeroport from airports')
number_airports <- fetch(question_2, n=-1)
number_airports

#Le nombre de compagnies
question_21 <- dbSendQuery(connection, 'select count(carrier) as nombre_de_compagnie from airlines')
number_carrier <- fetch(question_21, n=-1)
number_carrier

#Le nombre de destinations
question_22 <- dbSendQuery(connection, 'select count(distinct dest) as nombre_de_destination from flights')
number_destination <- fetch(question_22, n=-1)
number_destination

#Le nombre d'avions
question_23 <- dbSendQuery(connection, 'select count(distinct tailnum) as nombre_d_avions from planes')
number_planes<- fetch(question_23, n=-1)
number_planes

#Le nombre de fuseaux horaires
question_24 <- dbSendQuery(connection, 'select count(distinct tz) as nombre_fuseau_horaire from airports')
number_timezone<- fetch(question_24, n=-1)
number_timezone

#Methode 2
##Complétons manuellement les champs tz et Tzone la table Airports pour être plus précis.
##new_airports.modif<- edit(airports_edit)
#Réacfectation de la table modifier dans notre dataframe Airports
##airports <- new_airports.modif

#Le nombre de zones
question_25 <- dbSendQuery(connection, 'select count(dst) as nombre_de_zones from airports where dst = "N" ')
number_zone<- fetch(question_25, n=-1)
number_zone
```

**3. Quel est l’aéroport de départ le plus emprunté ? Quelles sont les 10 destinations les plus (moins) prisées ? Quelle sont les 10 avions qui ont le plus (moins) décollé ? **

```{r}

# L'aeroport de départ le plus emprunté
question_3 <- dbSendQuery(connection, 'select count(origin) as nombre_aeroport ,origin,airports.name as nom_aeroport from flights inner join airports on flights.origin = airports.faa group by origin limit 1')
aeroport_most_used<- fetch(question_3, n=-1)
aeroport_most_used
# check
table(flights$origin)

# Les 10 destinations les plus prisées
question_31 <- dbSendQuery(connection, 'select count(dest) as nombre_destinations ,airports.name as nom_aeroport from flights inner join airports on flights.dest = airports.faa group by dest order by nombre_destinations desc limit 10')
aeroport_10most_used<- fetch(question_31, n=-1)
aeroport_10most_used
# check
tail(sort(table(flights$dest)),10)

# Les 10 destinations les moins prisées
question_32 <- dbSendQuery(connection, 'select count(dest) as nombre_destinations ,airports.name as nom_aeroport from flights inner join airports on flights.dest = airports.faa group by dest order by nombre_destinations asc limit 10')
aeroport_10less_used<- fetch(question_32, n=-1)
aeroport_10less_used
# check
head(sort(table(flights$dest)),10)

# Les 10 avions qui ont le plus décollé
question_33 <- dbSendQuery(connection, 'select count(flights.tailnum) as nombre_avion, flights.tailnum, air_time from flights inner join planes on flights.tailnum = planes.tailnum where air_time != "NA" group by tailnum order by nombre_avion desc limit 10')
aeroport_10most_takeon<- fetch(question_33, n=-1)
aeroport_10most_takeon
# check
tail(sort(table(flights$tailnum)),10)

# Les 10 avions qui ont le moins décollé
question_34 <- dbSendQuery(connection, 'select count(flights.tailnum) as nombre_avion, flights.tailnum, air_time from flights inner join planes on flights.tailnum = planes.tailnum where air_time != "NA" group by tailnum order by nombre_avion asc limit 10;')
aeroport_10most_takeon<- fetch(question_34, n=-1)
aeroport_10most_takeon
# check
head(sort(table(flights$tailnum)),10)
```
**4. Trouver combien chaque compagnie a desservi de destination ; combien chaque compagnie a desservie de destination par aéroport d’origine. Réaliser les graphiques adéquats qui synthétisent ces informations ? **

```{r}

# Combien chaque compagnie a désservi de destination
question_4 <- dbSendQuery(connection, 'select count(dest) as nombre_de_destination, flights.carrier as compagnie,name from flights inner join airlines on flights.carrier = airlines.carrier group by compagnie')
number_dest_bycarrier <- fetch(question_4, n=-1)
number_dest_bycarrier
# check
table(flights$carrier)

# Combien chaque compagnie a désservi de destination par aéroport d'origine
question_41 <- dbSendQuery(connection, 'select count(dest) as nombre_de_destination, flights.carrier as compagnie,airlines.name,flights.origin as origin,airports.name as aeroport from flights inner join airlines on flights.carrier = airlines.carrier inner join airports on flights.origin = airports.faa group by compagnie,origin')
number_destbycarrier_origin <- fetch(question_41, n=-1)
number_destbycarrier_origin

# graph_4 
graph_4 <- ggplot(data = number_dest_bycarrier, aes(x=compagnie, y = nombre_de_destination)) + geom_col(fill = "orange",color='white') + geom_text(aes(label = nombre_de_destination), vjust= 1.2, size = 3.5, colour="black") + theme_gray() + xlab("nom de la compagnie") + ylab("nombre de destinations desservi") + ggtitle("Le nombre de destination desservi par compagnie") + geom_text(aes(label = name), size = 3, colour = "white", vjust = 0) + theme(panel.background = element_rect(fill = "skyblue", colour = "black",size = 3))
# appel du graph avec ggplotly
graph_4
ggplotly(graph_4)


# graph_41 
graph_41 <- ggplot(data = number_destbycarrier_origin) + geom_point(aes(x = compagnie, y = nombre_de_destination, color = origin, size = nombre_de_destination)) + theme_dark() + xlab("Compagnie") + ylab("Nombre de destination desservi par aeroport d'origine") + ggtitle("Nombre de destination desservi par aéroport") + theme(panel.background = element_rect(fill = "black", colour = "purple",size = 5))
graph_41
ggplotly(graph_41)
```


**5. Trouver tous les vols ayant atterri à Houston (IAH ou HOU) (indice : 9313 vols). Combien de vols partent de NYC airports vers Seattle (indice : 3923 vols), combien de compagnies desservent cette destination (indice : 5 compagnies) et combien d’avions “uniques” (indice : 936 avions) ? (anciennement la 9).**

```{r}

# Tous les vols ayant atterri à Houston (IAH ou HOU)
question_5 <- dbSendQuery(connection, 'select count(*) as nombre_de_vol_pour_Houston from flights where dest in ("IAH","HOU")')
flight_landed_nyc<- fetch(question_5, n=-1)
flight_landed_nyc

# Le nombre de vols qui part de NYC airports vers Seattle
# Tous les aeroports de départ partent de New-York on peut le vérifier avec cette requête
verif_origin <- dbGetQuery(connection, 'select faa,name,tzone from airports where faa in("EWR","LGA","JFK")')
verif_origin

# Il suffit juste de mettre SEA == SEATTLE comme destination pour effectuer la requête
question_51 <- dbSendQuery(connection, 'SELECT count(*) as nombre_de_vol_vers_Seattle from flights where dest = "SEA"')
number_flights_nyc2seattle<- fetch(question_51, n=-1)
number_flights_nyc2seattle

# Le nombre de compagnies qui deservent SEATTLE
question_52 <- dbSendQuery(connection, 'SELECT count(distinct carrier) as nombre_de_compagnie_vers_Seattle from flights where dest = "SEA"')
number_carrier_toseattle<- fetch(question_52, n=-1)
number_carrier_toseattle

# Le nombre d'avion "unique"
question_53 <- dbSendQuery(connection, 'SELECT count(distinct tailnum) as nombre_d_avion_unique from flights where dest = "SEA"')
number_unique_plane<- fetch(question_53, n=-1)
number_unique_plane

```


**6.Trouver le nombre de vols unique par destination voir l’aperçu. Trier les vols suivant la destination, l’aéroport d’origine, la compagnie dans un ordre alphabétique croissant (en réalisant les jointures nécessaires pour obtenir les noms des explicites des aéroports)?**

```{r}
# Le nombre de vol unique par destination
question_6 <- dbSendQuery(connection, 'select count(distinct flight) as nb_vol_unique,dest,airports.name as airport_dest from flights inner join airports on flights.dest = airports.faa  group by dest order by nb_vol_unique desc')
number_vol_unique <- fetch(question_6, n=-1)
number_vol_unique

# Trions les vols suivant la destination, l'aeroport d'origine, la compagnie dans un ordre alphabétique croissant

question_61 <- dbSendQuery(connection, 'select ori.name as airport_origin,origin,des.name as airport_dest,dest,airlines.name as airlines_name,flights.carrier,origin,dest,flights.carrier,flight from flights inner join airports as ori ON flights.origin = ori.faa inner join airports as des ON flights.dest = des.faa inner join airlines ON flights.carrier = airlines.carrier group by origin,dest,carrier order by airport_origin,airport_dest,airlines_name asc')
trie_vol <- fetch(question_61, n=-1)
trie_vol
```


**7.Quelles sont les compagnies qui n'opèrent pas sur tous les aéroports d’origine ? Quelles sont les compagnies qui desservent l’ensemble de destinations? Faire un tableau où l’on récupère l’ensemble des origines et des destinations pour l’ensemble des compagnies.**

```{r}
# NB: Nous savons que dans notre dataset il existe en unique que 3 aeroports d'origin.
# les compagnies qui n'opèrent pas sur tous les aéroports d’origine
question_7 <- dbSendQuery(connection, 'select count(distinct origin) as nb_origin,flights.carrier as name_carrier,airlines.name from flights INNER JOIN airlines ON flights.carrier = airlines.carrier group by name_carrier having count(distinct origin) != 3')
carrier_noatAll_airport <- fetch(question_7, n=-1)
carrier_noatAll_airport

# les compagnies qui desservent l’ensemble des destinations
# NB: Nous savons qu'il existe 1462 destination , vérifiable par les requêtes "select count(distinct faa from airports") ou "Select count(distinct dest from flights")
question_71 <- dbSendQuery(connection, 'select count(distinct dest) as nb_dest,flights.carrier,airlines.name from flights INNER JOIN airlines ON flights.carrier = airlines.carrier group by carrier order by nb_dest desc')
carrier_atAll_airport <- fetch(question_71, n=-1)
carrier_atAll_airport

#Faire un tableau où l’on récupère l’ensemble des origines et des destinations pour l’ensemble des compagnies.
question_72 <- dbSendQuery(connection, 'select flights.carrier,airlines.name,count(distinct origin) as nb_origin,count(distinct dest) as nb_dest from flights INNER JOIN airlines ON flights.carrier = airlines.carrier group by carrier order by nb_dest desc')
ens_origin_dest_recap <- fetch(question_72, n=-1)
ens_origin_dest_recap

```

**8.Quelles sont les destinations qui sont exclusives à certaines compagnies (indice : 29 destinations en tout) ?**

```{r}

# Le nombre de destinations qui sont exclusives à certaines compagnies
question_8 <- dbSendQuery(connection, 'select flights.dest,airports.name,count(distinct flights.carrier) as nombre_dest, count(flights.dest) as nb_dest,airlines.name from flights inner join airports on flights.dest = airports.faa inner join airlines on flights.carrier = airlines.carrier group by dest having count(distinct flights.carrier) = 1 order by airlines.name asc')
dest_exclusives_carrier<- fetch(question_8, n=-1)
dest_exclusives_carrier

```

**9.Filtrer le vol pour trouver ceux exploités par United, American ou Delta (indice : 139 504 vols en tout) ?**

```{r}

# Filtrer le vol pour trouver ceux exploités par united, America ou Delta
question_9 <- dbSendQuery(connection, 'select count(*) as nb_vol,airlines.name from flights inner join airlines on flights.carrier = airlines.carrier where name like "%UNited%" or name like "%American%" or name like "%Delta%" ;')
vol_exploite_United<- fetch(question_9, n=-1)
vol_exploite_United

```



# **Reporting**
## *pic de trafic aéroportuaire*
### *A noter qu'ici on pourra soit utiliser du DPLYR ou du SQL Selon le degré de difficulté de la question et sur la technologie auquelle on se sent le mieux" :-)

  Votre objectif est de créer des viz de l’évolution du trafic (par ex : par mois,  les périodes de pic, les jours spéciaux : vacances, fêtes nationales,...) ? Ceci nécessite la maîtrise de la gestion du temps dans SQL et dans les autres langages (indice : pour R, utiliser lubridate pkg). Une des applications possibles est de prédire le trafic à des dates futures. Sachez qu’un modèle plus complexe et que certains traitements sur les données sont néanmoins nécessaires qui sont hors du cadre de ce projet : traiter par ex la saisonnalité.
  
##### *Répondons avant aux Questions suivantes :* 

**1. Constater qu’on peut reconstituer l’information sched_dep_time à partir de year, month, day, hour et minute. Transformer alors cette colonne en type datetime. Transformer également dep_time, arr_time et sched_arr_time et supprimer les colonnes year, month, day, hour, minute.**
```{r}
flights <- flights %>%
      mutate(new_sched_dep_time = lubridate::make_datetime(year, month, day, hour, minute)) %>%
      group_by(origin) %>%
      arrange(new_sched_dep_time)

# Lancement du nouveau flight avec la nouvelle colonne shed_dep_time
flights
```


**2. Construire une viz par facette où on peut comparer le trafic mensuelle des trois aéroports d’origine en y indiquant sur chaque graphe la ligne qui représente la moyenne mensuelle respective à chaque aéroport ?**
  Indice : Pensez à bien choisir l’indicateur ? Par ex, si vous retenez le nombre de vol mensuel, se rappeler que tous les mois n’ont pas 31 jours et il faut donc faire une pondération ? 
Sinon, une autre piste est de calculer le nombre moyen de vol par mois ?
Éventuelles autres pistes, soyez curieux ?

```{r}
# regroupons les vol par mois
m_flights <- flights %>% group_by(month) %>% summarise(Count=n())

# Calculons la moyenne mensuelle des vols
moy_mensuelle <- mean(m_flights$Count, na.rm = TRUE) # C'est la limite de la courbe constante

# Graphique
traffic_month <- ggplot(m_flights, aes(x=month, y=Count)) + 
  geom_line(color="red") + geom_point(color="cyan") + 
  ylab(label = "number flight month") +
  geom_hline(yintercept = moy_mensuelle, color="yellow") + 
  scale_x_discrete(limits=month.abb) + 
  theme(panel.border = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "white",colour = "white")) +
  theme_dark()

# lancement graphique
traffic_month
```


**3. Enrichir la dernière viz en ajoutant la courbe du taux d’accroissement mensuelle ?**
```{r}
 # Déja inclu dans la question précedente : améliorant le avec plotly
ggplotly(traffic_month)
```


**4. Quelle est le top 3 des aéroports d’origine/de destination qui enregistre le plus de trafic ?**
```{r}
# Ici utilsons dbGetQUery pour montrer sa syntaxe comparer au dbSentQuery.
# Top 3 des aéroport d'origine qui enregistre le plus de trafic ( ON sait de toute façon qu'il y'en a que 3 dans notre dataset, donc ce sera les 3 aéroports d'origine en question.)
top_3_origin_airports <- dbGetQuery(connection,"Select count(origin) as nb_origin,origin,name as airport_name from flights inner join airports on flights.origin = airports.faa group by origin ")
top_3_origin_airports

# Top 3 des aéroport de destination qui enregistre le plus de trafic
top_3_dest_airports <- dbGetQuery(connection,"Select count(dest) as nb_destination,dest,name as airport_name from flights inner join airports on flights.dest = airports.faa group by dest order by nb_destination desc limit 3")
top_3_dest_airports
```

```{r}
# cluster airports USA
#Visualisons les aeroport d'origine grace à) leaflet
airport_base <- airports %>% select(name,lon,lat,tzone)

# Répartition des aéroports sur la carte des USA
usa_map_airports <- leaflet(airport_base) %>% addTiles() %>%
  addMarkers(clusterOptions = markerClusterOptions(),
             lng = ~lon, lat = ~lat, popup = ~name)
usa_map_airports


# Top 3 des vols les plus fréquentés origin flights------
gps <- data.frame(lat = c(40.6895314,40.6413111,40.7769271),lon = c(-74.1744624,-73.7781391,-73.8739659))
o_flights <- flights %>% group_by(origin) %>% summarise(Count=n())
airports_top <- cbind(o_flights, gps)

airports_top

num <- as.numeric(c(6000,4000,3000))

airports_ny <- leaflet(airports_top) %>% addTiles() %>%
  addCircles(lng = ~lon, lat = ~lat, weight = 1,
             radius = ~num, popup = ~c(origin))

airports_ny
```



**5. Filtrer les vols pour obtenir seulement qui ont ont été effectué:**
*Le 1er janvier ; Combien de vols ont été effectué tous les jours / En novembre ou en décembre / Lors des jours spéciaux suivants : le 25/12 “Christmas Day” / 01/01 “jour de l’an”, 04/07 “Independance Day” et le 29/11 “Thanksgiving Day” ; En été (juillet, août et septembre), Dont le départ s’est effectué entre minuit et 6h (inclus) ?*
```{r}
# Le 1er janvier: Combien de vols ont été effectué tous les jours
new_yr <- filter(flights, month == 1, day == 1)
new_year <- new_yr %>% group_by(month,day) %>% summarise(nombre_ny=n())
new_year

# En novembre ou en décembre (On peut les faire séparément pour avoir un total)
# -> mois de novembre
nov <- filter(flights, month == 11)
novembre <- nov %>% group_by(month) %>% summarise(nombre_nov=n())
novembre
# -> mois de décembre
dec <- filter(flights, month == 12)
decembre <- dec %>% group_by(month) %>% summarise(nombre_dec=n())
decembre

# Lors des jours spéciaux suivants :
# -> le 25/12 “Christmas Day"
christmas <- filter(flights, month == 12, day == 25)
christmas_day <- christmas %>% group_by(month,day) %>% summarise(nombre_ligne=n())
christmas_day

# -> le 01/01 “jour de l’an" (Question déja posé pour le 1er janvier)
new_yr <- filter(flights, month == 1, day == 1)
new_year <- new_yr %>% group_by(month,day) %>% summarise(nombre_ligne=n())
new_year

# -> le 04/07 “Independance Day"
Indep_day <- filter(flights, month == 7, day == 4)
independance_day <- Indep_day %>% group_by(month,day) %>% summarise(nombre_ligne=n())
independance_day
# -> le 29/11 “Thanksgiving Day”
Thanks <- filter(flights, month == 11, day == 29)
Thanksgiving <- Thanks %>% group_by(month,day) %>% summarise(nombre_ligne=n())
Thanksgiving

# En été (juillet, août et septembre)
depart_ete <- filter(flights, month %in% c(7, 8, 9)) # ou filtre dont la condition serait  month >= 7 & month <= 9
#depart_ete

# Dont le départ s’est effectué entre minuit et 6h (inclus)
depart_entre_mid_6h <- filter(flights, dep_time <= 600 | dep_time == 2400) # 600 = 6h so 5,4,3,2,1,0(dep_time == 2400)
#depart_entre_mid_6h

#------------------------------------------------------------------------------------------------------------------------------------
# Pour pouvoir faire des comparaison pour la question suivante regroupant les informations pour en ressortir les insights signifiants
# -> fête des grandes vacances
#vacances d'été, summer holidays (juillet + août + septembre)------
# juillet
juillet <- filter(flights, month == 7)
july_vac<- juillet %>% group_by(month) %>% summarise(nombre_ligne = n())
# aout
aout <- filter(flights, month == 8)
august_vac <- aout %>% group_by(month) %>% summarise(nombre_ligne = n())
# septembre
septembre <- filter(flights, month == 9)
septembre_vac <- septembre %>% group_by(month) %>% summarise(nombre_ligne = n())

# Summer holidays (juillet,aout,septembre)
summer_holidays <- dplyr::bind_rows(july_vac,august_vac,septembre_vac) #Comme vue dans le projet Uber on utilise bind_rows pour concatener

month_name<- data.frame(
month_name = c("juillet","août","septembre")
)

summer_holidays <- dplyr::bind_cols(summer_holidays,month_name)
summer_holidays

summer_out <- ggplot(summer_holidays, aes(x=month_name,y=nombre_ligne))+
  geom_bar(stat="identity",width = 0.2,color="blue",fill="cyan")+
  geom_text(aes(label=nombre_ligne), vjust=1.5, color="purple", size=3)+
  theme_dark()

summer_out

#---------------------------------------------------------------------------------------------------------------------------------------

# Les jours clés de l'année
year_holiday <- dplyr::bind_rows(new_year,christmas_day,independance_day,Thanksgiving)

event <- data.frame(
event = c("new_year","christmas_day","independance_day","Thanksgiving")
)

# Key_holiday
year_holiday <- dplyr::bind_cols(year_holiday,event)

special_day_out <- ggplot(year_holiday, aes(x = event, y = nombre_ligne))+
  geom_bar(stat="identity",width = 0.2,color="purple",fill="orange")+
  geom_text(aes(label=nombre_ligne), vjust=-0.5, color="yellow", size=4)+
  theme_minimal() + theme_dark()

special_day_out


```

**6. Observe-t-on plus de trafic en fin de semaine ou en jours ouvrés ? Observe-t-on plus ou moins de trafic pendant les jours spéciaux de l’année par rapport à la moyenne annuelle ? Peut-on faire une viz comme celle-ci (cliquer ici ou encore comme celle-ci)**
```{r}
# Voir graph
```

## *Retard à l’arrivée et/ou au départ ?*

  Votre objectif est de calculer un(des) indicateur(s) de “qualité” (fiabilité) d’une ligne de vol. Par ex, la proportion des vols retardés vers une même destination chez une certaine compagnie ? Et de créer une viz qui indique le classement des compagnies/vols suivants le critère que vous avez retenu ?  

Répondre avant aux Q suivantes (pour se familiariser avec les données) : 
Quels sont les vols les plus retardés : 

**1. A l’arrivée (arr_delay), au départ (dep_delay), au départ et à l’arrivée à la fois ?**
```{r}
# les vols les plus retardés A l’arrivée (arr_delay)
most_delayed_arr_delay <- select(flights, arr_delay) %>% arrange( desc(arr_delay))
most_delayed_arr_delay
# les vols les plus retardés au départ (dep_delay)
most_delayed_dep_delay <- select(flights, dep_delay) %>% arrange( desc(dep_delay))
most_delayed_dep_delay
```

**2. Calculer le retard moyen au départ pour l’ensemble des vols et le retard moyen journalier au départ ?**
```{r}
#départ
moy_dep_retard <- mean(flights$dep_delay, na.rm = TRUE)

#Retard par jour
total_dep_delay <- sum(flights$dep_delay, na.rm = TRUE)
day_dep_delay <- sum(flights$day, na.rm = TRUE) 
moy_dep_jour <- total_dep_delay / day_dep_delay * 60
# 0.78 * 60min soit environs 47 minutes
```

**3. Combien de vols sont arrivés avec plus de 2 heures de retard, alors qu'ils étaient partis à l’heure ? Qui n'ont pas été retardés de plus de 2 heures ni au départ ni à l'arrivée ? **
```{r}
nb_no_delay <- filter(flights, dep_delay < 120 & arr_delay < 120)
#TOTAL
nb_no_delay <- group_by(nb_no_delay) %>% summarise(volnov=n())

```

**4. Qui ont décollé (resp. ont atterri) plus tôt que prévu ? **
```{r}
advanced_flights <- filter(flights, dep_delay < 0)
# somme
advanced_flights <- group_by(advanced_flights) %>% summarise(volnov=n())
```

**5. Qui sont partis avec une heure de retard ou plus, mais ont rattrapé plus de 30 minutes lors du vol ? Indice : gain = arr_delay - dep_delay **
```{r}
filter(flights, dep_delay >= 60, dep_delay-arr_delay > 30)

```

**6. On déduire le gain par heure pour chaque vol où le pilote a réussi à rattraper partiellement ou complètement lors du vol le retard du départ ?  Indice : gain_per_hour = gain / hours avec hour = air_time / 60**
```{r}
dep <- sum(flights$dep_delay, na.rm = TRUE)
arr <- sum(flights$arr_delay, na.rm = TRUE)
hours <- sum(flights$hour, na.rm = TRUE)

gain_c <- dep - arr
total_gain_c <- gain_c / hours

total_gain_c <- total_gain_c * 60

```

**7. Trier les vols selon leur vitesse (speed = distance/air_time * 60) ? Quelles sont les vols qui ont parcouru la distance la plus grande/la plus petite (long courrier/court courrier) ?**
N.B : pour les deux dernières questions, essayer d’y répondre en créant les nouvelles variables (gain et speed)mais aussi sans les créer (important).
```{r}
# flights <- mutate(flights, 
#                   distance_km = distance / 0.62137,
#                   vitesse = distance_km / air_time * 60)
# select(flights,distance_km, vitesse)    avoid--------------------------------------------------


distance_cal <- select(flights,distance,origin,dest)
```


## *Retard à l’arrivée et/ou au départ ?*

  On s’intéresse à la relation entre le retard à l’arrivée et le type de vol : long courrier, moyen courrier ? En d’autres termes, explorer la relation entre la distance et le retard moyen pour chaque destination. Pour cet effet, 

**1. Regrouper les flights par dest ;**
```{r}
# Requête en SQL
flights_by_dest <- dbGetQuery(connection,"Select * from flights group by dest")
flights_by_dest

# On obtient des résultats différents comparé avec R qui peut prendre en compte les nuls, alors poursuivons en R
flights_by_dest_R <- flights %>% group_by(dest) %>% mutate(delay_moy = mean(arr_delay, na.rm=TRUE)) 
flights_by_dest_R

```

**2. Calculer le delay_moy pour chaque groupe de dest ; **
```{r}
delay_moy_by_dest <- flights %>% group_by(distance) %>% mutate(dist_moy = mean(distance, na.rm=TRUE)) 
delay_moy_by_dest
```

**3. En comptant le nombre d'éléments dans chaque groupe, vérifier que la distance est la même pour chaque destination, sinon calculer la dist_moy pour l’harmoniser.**
```{r}
verif_idem_dest <- select(flights,dest) %>% filter(dest=="HNL")
verif_idem_dest
```

**4. Remarquer que la destination HNL (outlier) est presque deux fois plus loin que le seconde destination plus distante. **
```{r}
verif_dest_hnl <- flights %>% 
                group_by(distance) %>% 
                filter(dest != "HNL") %>% 
                arrange(desc(distance)) %>% 
                mutate(dist_moy = mean(distance, na.rm=TRUE)) 

# ON remarque bien que la destination HNL (Outlier) est deux fois plus loin que la szconde destination.
```

**5. N’oublier pas alors de l’exclure parce que sinon il constitue un outlier (point perturbant) pour l’analyse.**
```{r}
# verif_exclu <- select(dist_flights,dest) %>% filter(dest=="HNL")

```

**6. Quelles sont les destinations les plus touchés et les compagnies concernées (par le problème du retard)? NB:erreur sur l'énoncé : question 8?**
```{r}
#Faisons la jointure de la table airlines et flights
company_flights <- inner_join(airlines,flights, by = "carrier")

#Compagnie concerné par le problème du retard
#select(company_flights,name,dest,delay_moy,distance) %>% arrange(desc(delay_moy)) %>% head(5)

```

**7. Fournir un résumé statistique des vars (arr_delay) et (dep_delay) et une représentation graphique qui enseigne ce phénomène ? NB: Q9 énoncé?**
```{r}
# Appelons la fonction summary pour les résumé statistique sur les variables ci-dessus
# Arr_delay
summary(flights$arr_delay)

# Dep_delay
summary(flights$dep_delay)
```

**8. Quelle est l’aéroport où on enregistre le retard moyen le plus faible? NB: Q10 enoncé **
```{r}
#weak_delay_airport <- select(company_flights,name,dest,delay_moy,distance) %>% arrange(delay_moy) %>% head(1)
#weak_delay_airport
```

**9. Existe-t-il une relation entre l’heure de décollage d’un avion et le retard ? NB: Q11 énoncé**
```{r}
relat_dec_retard <- select(company_flights,hour,dep_delay)

graph_relat_dec_retard <- ggplot(relat_dec_retard, aes(x=hour,y=dep_delay)) +
                          geom_point( color="yellow", size=3) + theme_dark()
# Lancement du graph
  graph_relat_dec_retard
```


## *Vols annulés ou encore la gestion des données manquantes ?* 

  Votre objectif est de calculer le nombre de vols annulés, d’affiner le résultat par destination / compagnie et dans le temps. Réaliser la viz qui résume ce phénomène ? 

**1. Remarquer que (dep_time), (dep_delay), (arr_time) et (arr_delay) comportent des données manquantes. Quelle est la proportion des données manquantes pour chacune de ces vars ? Y’a-t’il d’éventuelles autres colonnes qui sont touchés par des NA.**
```{r}

```

**2. Si on suppose que lorsque (dep_time) et (arr_time) sont à la fois manquantes, le vol correspondant est alors un vol annulé. Calculer alors combien de vols ont été annulé et affiner le résultat par destination, par compagnie**
```{r}
# créons un nouveau flight na avec les colonnes que nous voulons
na_flights <- select(company_flights,name,origin,dest,dep_delay,arr_delay,arr_time,dep_time,distance)

# Vol annulé par company au départ
vol_depart_annule <- na_flights %>% filter(is.na(dep_time)) %>%  group_by(dest,name) %>% 
  summarise(volnov=n())

#vol annulé par company à l'arrivé
vol_arrive_annule <- na_flights %>% filter(is.na(arr_time)) %>%  group_by(dest,name) %>% 
  summarise(volnov=n())

delay_desc <- na_flights %>% 
  arrange(desc(is.na(dep_time)),
          desc(is.na(dep_delay)))
```

**3. Sort the flights by departure time dep_delay in descending order but NA values first? Hint: use is.na()**
un lien: https://stackoverflow.com/questions/37760580/dplyr-arrange-function-sort-by-missing-values

```{r}

```

**4. Sort the flights by dep_delay in descending order and dep_time in ascending order but NA values first?**
```{r}
arrange(flights, desc(dep_delay))
arrange(flights, (dep_time))
```


## *Calculer de durée*

**1. Actuellement, dep_time et sched_dep_time sont pratiques, mais difficiles à calculer, car ils ne sont pas vraiment des nombres continus. Convertissez-les en une représentation plus pratique du nombre de minutes écoulées depuis minuit.**
```{r}
# POur cette question j' utilise les arrondis
convert_dt_st <- mutate(flights,
                                dep_time = 60 * floor(dep_time/100) + (dep_time - floor(dep_time/100) * 100),
                                sched_dep_time = 60 * floor(sched_dep_time/100) + (sched_dep_time - floor(sched_dep_time/100) * 100))
convert_dt_st
```


**2. Comparez dep_time, sched_dep_time et dep_delay. Comment vous attendez-vous à ce que ces trois colonnes soient liés?Trouvez les 10 vols les plus retardés en utilisant une fonction de classement. Comment voulez-vous gérer les cravates? Lisez attentivement la documentation de min_rank()**
```{r}
# compare_dt_sdt_dd <- flights %>% 
#                        mutate(dep_time = (dep_time %/% 100) * 60 + (dep_time %% 100),
#                               sched_dep_time = (sched_dep_time %/% 100) * 60 + (sched_dep_time %% 100),
#                               arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
#                               sched_arr_time = (sched_arr_time %/% 100) * 60 + (sched_arr_time %% 100))%>%
#                        transmute(near((sched_dep_time + dep_delay) %% (60*24), dep_time, tol=1))

# Quand on demande de comparer dep_time, sched_dep_time et dep_delay, le premier reflexe est de se dire que: "dep_time == sched_dep_time + dep_delay"


```


```{r}
# Les 10 vols les plus retardés en utilisant une fonction de classement min_rank(A vérifier)
 ten_delayed_flights <-  filter(flights, min_rank(desc(dep_delay))<=10)
 ten_delayed_flights <-  flights %>% top_n(n = 10, wt = dep_delay) %>%  arrange(desc(dep_delay)) %>%  head(10)
 ten_delayed_flights
```


**3. Comparez air_time avec arr_time - dep_time. Qu'espérez-vous voir? Que vois-tu? Que devez-vous faire pour le réparer?**
```{r}
# compare_air_time <- flights %>% 
#                       mutate(dep_time = (dep_time %/% 100) * 60 + (dep_time %% 100),
#                              sched_dep_time = (sched_dep_time %/% 100) * 60 + (sched_dep_time %% 100),
#                              arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
#                              sched_arr_time = (sched_arr_time %/% 100) * 60 + (sched_arr_time %% 100)) %>%
#                       transmute((arr_time - dep_time) %% (60*24) - air_time)

# Quand on demande de comparer air_time avec arr_time - dep_time on espère voir une variation de air_time, car la soustraction en arithmétique est pour voir si il y'a une grande variation ou écart.
# Nous voyons que arr_time et dep_time sont de format différent donc nous pouvons convertir l'un au format de l'autre, je préconise arr_time au format de dep_time pour que la soustraction nous donne une réponse fiable. DOnc pour la réparer convertir "arr_time" qui est au format heure en minutes après minuit.
```


## *Gestion des données géospatiales*
On souhaite obtenir le graphique ci-dessous:

Je m’explique : vous avez besoin des coordonnées des aéroports (longitude et latitude) information contenu dans la table airports Et des origine et des destinations des vols  (donc la table flights). Par la suite, on doit faire une jointure entre ces deux tables et construire 4 nouvelles variables : origin_lon, origin_lat, dest_lon et dest_lat.

**1.Enfin, dessiner la carte des Etats-Unis et placer des flèches origine-destination.**  
```{r}
# Faisons la double jointure entre flights et airports pour matcher les noms des origines et des destinations.
flights_latitude_longitude <- flights %>%
  inner_join(select(airports, origin = faa, origin_lat = lat, origin_lon = lon),
             by = "origin") %>%
  inner_join(select(airports, dest = faa, dest_lat = lat, dest_lon = lon),
             by = "dest" )


# Selectionnons les 5 trajectoires les plus effectuées sur les 100 trajectoires
flights_latitude_longitude <- flights_latitude_longitude  %>% group_by(origin,dest,origin_lon,origin_lat,dest_lon,dest_lat)  %>% summarise(nb_vol=n()) %>% 
filter(dest != "HNL") %>% filter(dest != "ANC") %>% arrange(desc(nb_vol)) %>% head(5)
# Représentons le graph
 graph_usa_geo <-  ggplot(flights_latitude_longitude,aes(
    x = origin_lon, xend = dest_lon,
    y = origin_lat, yend = dest_lat, color = "red")) +
  borders("state") + geom_segment(arrow = arrow(length = unit(0.1, "cm"))) + coord_quickmap() +
  labs(y = "Latitude", x = "Longitude") + theme_light()



#graph_4 <- ggplot(data = number_dest_bycarrier, aes(x=compagnie, y = nombre_de_destination)) + geom_col(fill = "orange",color='white') + geom_text(aes(label = nombre_de_destination), vjust= 1.2, size = 3.5, colour="black") + theme_gray() + xlab("nom de la compagnie") + ylab("nombre de destinations desservi") + ggtitle("Le nombre de destination desservi par compagnie") + geom_text(aes(label = name), size = 3, colour = "white", vjust = 0) + theme(panel.background = element_rect(fill = "skyblue", colour = "black",size = 3))

# Lancement du graph
 graph_usa_geo
 
 # Lancement du ggplot
 ggplotly(graph_usa_geo)
 

```

**2. Tracer sur la carte des Etats-Unis les lignes aériennes les plus empruntés par les avions ? Vous avez besoin aussi de déterminer les 5 destinations les plus   la vez trajectoire des 100 **
```{r}
# # Affichons les trajectoires
# usairports <- filter(airports, lat < 48.5)
# usairports <- filter(usairports, lon > -130)
# usairports <- filter(usairports, faa!="JFK") 
# jfk <- filter(airports, faa=="JFK") 
# 
# # Ici on cree le fond de la carte
# map("world", regions=c("usa"), fill=T, col="grey8", bg="grey15", ylim=c(21.0,50.0), xlim=c(-130.0,-65.0))
# 
# # Recouvrons les aeroports
# points(usairports$lon,usairports$lat, pch=3, cex=0.1, col="red")
# 
# for (i in (1:dim(usairports)[1])) { 
#   inter <- gcIntermediate(c(jfk$lon[1], jfk$lat[1]), c(usairports$lon[i], usairports$lat[i]), n=200)
#   lines(inter, lwd=0.1, col="turquoise")    
# }
```



# *R pur : optimiser, traiter, divers manip sur les objets*

**1. Différence entre read.csv et read_csv:**
Relire le fichier airlines.csv à l’aide des fonctions read.csv et read_csv ? Quelles sont les différences entre ces deux fonctions. Transformer les colonnes carrier et name en factor ?
```{r}
#On a pas de fichier Airlines.csv à notre porté (que des fichier rda), alors exportons notre dataframe airline en .csv

# Voir notre répertoire de travail pour voir si on a besoin de l'arborescence du fichier à importer
# getwd()                        #arborescence = /home/hurgland/Bureau/Projet Nycflights/airlines.csv

# Extraction du dataframe en .csv
write.csv(airlines, file = "airlines_csv")

# Importons les fichiers csv avec les fonctions read.csv et read_csv pour voir la différence.
# read.csv:
import_airline_1 <- read.csv(file = 'airlines_csv')
# read_csv
# import_airline_2<- read_csv(file = 'airlines_csv')



# Conclusion: au niveau de:
# Rmarkdown: le read_csv empêche l'exportation du Knit ce qu n'est pas le cas du read.csv
# R / Rtudio : read_csv est nettement plus rapide pour les gros fichiers .csv ce qui n'est pas le cas pour read.csv
# Si il y'a un espace après chaque "," dans le fichier csv, read.csv() le prend en compte or read_csv() ne le fait pas.
# read_csv() donne des indication sur les colonnes, leur caractéristiques, class et donne des warning (Dans ce cas, s'il manque des noms de colonnes)




# Transformons les colonnes carrier et name en factor ( On sait d'après read_csv que name et carrier sont des caractères d'où cette question)
#Vérifions la class de carrier
class(import_airline_1$carrier)
#Vérifions la class de name
class(import_airline_1$name)

# Carrier et name sont déja en factor, mais une syntaxe si ce n'était le cas.
carrier_factor <- factor(import_airline_1$carrier)
name_factor <- factor(import_airline_1$name)

#vérifions:
class(carrier_factor)
class(name_factor)
```


**2. Lorsqu'on a des variables a la fin de la data frame comment on peut changer l’ordre des colonnes?**
```{r}

# Lorsqu'on a des variables a la fin de la data frame, on indique l’ordre dans lequel on veut voir se succéder les colonnes pour pouvoir changer l’ordre des colonnes. Par le numéro des colonnes ou le nom des colonnes.

# 1.Créons un nouveau dataframe df et affectons le les 2 colonnes qu'il nous faut
df <- import_airline_1[,2:3]

# Vérifions df
df

# 2.Modifions l'ordre des colonnes
df_colonne_inverse <-  df[,c("name","carrier")]

# Vérifions df_colonne_inverse
df_colonne_inverse

# cqfd mais il existe d'autres méthodes
```


**3. Gestion des NA :**
Calculer NA^0, NA|TRUE, FALSE&NA ? Pouvez-vous comprendre la règle générale? (NA * 0 est un contre-exemple délicat!)/
```{r}
# Calcul 1:
NA ^ 0  # NA ^ 0 retourne comme résulat 1 , on sait que tout nombre à la puissance 0 sera toujours égal à 1. Alors, il considère Na comme un nombre, même s'il est nulle et que nous ne connaissant pas sa valeur exacte.

# Calcul 2:
NA | TRUE # NA | TRUE retourne "TRUE" car en logique  VRAI OU FAUX donne toujours VRAI et vu que on ne connait pas ce que vaut Na comme dit ci-dessus, il nous importe de savoir ce que vaut NA. Tant que un des termes est VRAI l'expression sera évaluer VRAI.

# Calcul 3:
FALSE & NA  # FALSE & NA retourne "FALSE", car nous savons que les expressions avec "&" donne VRAI quand tout les termes sont VRAI. si il y'a un Faux alors l'expression sera évalué à FAUX ( d'où ce cas).


# Calcul 4:
NA * 0  # NA * 0 est évalué à NA, ce cas est un contre exemple délicat car le NA est ambigûe, il peut représenter à la fois la valeur vide ou quelque chose qui n'est pas un nombre, NaN par exemple car nous avons vu dans les questions précédentes que il pouvait etre comparé à un terme dont on veut evaluer l'expression. donc cette réponse peut avoir été définit comme ca de base car en toute logique il devrait être évaluer à 0. 
```

**4. recyclage des vecteurs :**
*Que retourne 1:3 + 1:10? Pourquoi?*
```{r}
# Calculons:
1:3 + 1:10
#  Notons: 1:3 = 1,2,3 et 1:10 = 1,2,3,4,5,6,7,8,9,10 (cela nous le savons déja)
#  Résultat :  Le calcul nous retourne un vecteur de taille 10 et un message d'alerte.
#  Pourquoi?: Cela est dû au fait que le vecteur le plus long contient le plus court qui, est dans un autre temps repété jusqu'a la longueur la plus longue.
#  l'addition est faite généralement entre 1:3 repeté (Extension de vecteur automatique) avec le vecteur de 1:10
#  On aura ce calcul dans la machine:
#  1,2,3,1,2,3,1,2,3
# +
#  1,2,3,4,5,6,7,8,9
#- ------------------
#  2,4,6,5,7,9,8,10,12,11
```
```{r}

```

